
CodeLlama是基于Llama2的代码实现的大规模语言模型系列，Llama2是由MetaAI开发的通用语言模型(详见第3章)。CodeLlama可以生成和讨论Python、C++、Java、PHP等多种编程语言中所用的代码。CodeLlama还能进行填充，即根据周围语境填充代码中缺失的部分，以及根据自然语言给出的指令生成符合所需功能的代码。

该模型有三种大小(70亿、130亿和340亿个参数)和三种类型(基本模型、Python微调和指令微调)，可覆盖广泛的应用。CodeLlama是在(16k)个词元组成的序列上进行训练的，可以处理多达(100k)个词元的输入。

在**Rozière Baptiste等人**于2023年8月发布的模型论文“**Code Llama: Open Foundation Models for Code**”中，作者描述了各种模型是如何通过代码理解和生成领域最流行的一些评估基准(包括HumanEval和MBPP)进行测试的，根据这些基准，CodeLlama模型的得分分别高达53%和55%。除了这些骄人的成绩，经过Python微调的CodeLlama最小版本(包含70亿个参数)在HumanEval和MBPP上的表现竟然超过了最大版本的Llama2(包含700个参数)。

现在，用这个模型进行一些测试。如前一节所述，可以利用ollama来加载模型。同样使用**Python的requests库与Ollama的REST API交互**方法：
```python
import requests
import json

def llm(prompt: str, model="codellama:7b") -> str:
    """调用CodeLlama模型生成回答"""
    endpoint = "http://localhost:11434/api/generate"
    payload = {
        "model": model,
        "prompt": prompt,
        "stream": False  # 关闭流式输出获取完整响应
    }
    
    try:
        response = requests.post(
            url=endpoint,
            data=json.dumps(payload),
            headers={"Content-Type":"application/json"},
            timeout=120  # 增加超时时间
        )
        response.raise_for_status()
        return response.json()["response"]
    
    except requests.exceptions.RequestException as e:
        print(f"API请求失败: {e}")
        return ""
```
现在用一些代码任务来测试它。

## 优化Python代码 
第一个任务是优化Python代码，使其更高效地运行。来看看模型在这项任务中的表现如何。在下面的代码片段中，只需提示模型以更高效的式重新生成所提供的代码：

```python
    prompt = """
    Regenerate the below code in a more efficient way.
    ```
    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result

    # 示例用法：
    n=5
    print("Factorial of", n, "is", factorial(n))
    ```
    """
    print(llm(prompt))
```

下面是输出结果：
>The provided code calculates the factorial of a given number using recursion. However, it is not very efficient because it uses a lot of memory and performs many redundant calculations. Here's a more efficient way to calculate the factorial:
```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

# 示例用法：
n = 5
print("Factorial of", n, "is", factorial(n))
```
>This implementation uses a more efficient algorithm that avoids the need for unnecessary recursive calls. It also uses much less memory and performs fewer calculations than the original code.

如上所示，模型能够使用递归方法，这种方法更高效，也更Python化。它还为用户深入研究函数背后蕴含的数学理论提供了参考。

## 代码填充（补全）
接下来，利用模型的补全功能，初始化一个函数来删除非ASCII字符。

>**回顾一下：**  
美国信息交换标准码(American Standard Code for Information Interchange, ASCII)是一种字符编码标准，使用7位二进制数来表示128个字符，如字母、数字、标点符号和控制代码。  
```非ASCII字符是指那些不属于ASCII标准的字符，使用7位以上的比特进行编码。它们包括特殊字符，如带重音的字母、字形、表意文字和数学符号。非ASCII字符可以使用不同的标准进行编码，如Unicode、ISO 8859- 1、Windows- 1252等。例如，字母é就是一个非ASCII字符，可以用Unicode编码为U+00E9，也可以用Windows- 1252编码为0xE9。```

**补全函数对应的代码：**

```python
prompt = """
Complete the following python code.
    ```
    import re
    def remove_non_ascii(my_string):
        return re.sub()
    ```
"""
print(llm(prompt))
```

**接收到的函数输出：**
```python
import re
def remove_non_ascii(my_string):
    return re.sub(r'[^x00-x7F]', '', my_string)
```

我们并没有告知大模型，原始代码的意图是什么，但是大模型结合对应的方法命名进行了合理的猜测，并给出了相应解释：
>This code uses the `re` module in Python to remove any non-ASCII characters from a given string. The `re.sub()` function is used to replace any character that is not in the range of ASCII characters (i.e., `x00-x7F`) with an empty string, effectively removing them from the string.  
The regular expression pattern passed to `re.sub()` is `r'[^x00-x7F]'`, which means "any character that is not in the range of ASCII characters". The `^` symbol at the beginning of the pattern negates the match, so it matches any character that is not in the range of ASCII characters. The `-` symbol between the `^` and `]` symbols negates the range of ASCII characters, so it matches any character that is outside of the range of ASCII characters.  
The function returns the modified string without any non-ASCII characters.

## bug解释
接着，将该模型用作错误修复工具，向它提示错误的函数，并要求它解释出错的原因以及如何修复：

```python
prompt = """
Identify the bug in the following code:
    ```

    # 错误的函数
    import random  
    a = random.randint(1,12)  
    b = random.randint(1,12) 
    for i in range(10): 
        question = "what is " + a + "x" + b + "？"
        answer = input(question) 
        if answer = a * b:
            print (Well done!) 
        else: 
            print("No.")
    ```
    ### Explanation:
"""
print(llm(prompt))
```
以下是输出结果：
>he bug in the code is that it uses `=` instead of `==` to compare the input with the expected answer.  
In Python, `=` is used for assignment, while `==` is used for comparison. The condition `if answer = a * b:` will always evaluate to True because it assigns the result of `a * b` to the variable `answer`, rather than checking if they are equal.  
Therefore, the code should be corrected as follows:
```python
# 正确的函数
import random  
a = random.randint(1,12)  
b = random.randint(1,12) 
for i in range(10): 
    question = "what is " + a + "x" + b + "？"
    answer = input(question) 
    if answer == a * b:
        print (Well done!) 
    else: 
        print("No.")
```

## 算法解答
最后，用自然语言要求模型为给定任务生成特定的Python代码，在本例中，这个任务就是编写一个函数，使其找出给定字符串中仅包含唯一字符的最长子串：

```python
prompt = """
Write a Python function that finds the longest substring of a given string containing only unique characters.
"""
print(llm(prompt))
```

输出结果如下：
```python
def longest_substring(s):
    """
    :param s: input string
    :return: longest substring of s containing only unique characters
    """
    start, end = 0, 1
    n = len(s)
    longest = ""
    
    while end < n:
        if s[end] in longest:
            longest = s[start:end]
            start = end
        end += 1
    
    return longest
```

按照第一节中大模型选型的决策框架要求，在这种情况下，使用了轻量级版本的模型（包含70亿个参数），仍然获得了很好的结果。这就是一个完美的例子，说明了在决定使用哪种大规模语言模型时，必须考虑应用程序要完成的任务：如果只对代码生成、补全、填充、调试或任何其他与代码相关的任务感兴趣，那么使用一个轻型开源模型就足够了，而不需要使用包含700亿个参数的最先进的GPT-4模型。

下一节将以代码生成和理解为背景，介绍第三个也是最后一个大规模语言模型。
