### 1：PDF文档处理

>PDF 是一种“便携式文档格式”，就像一本电子书籍或报告，能保持固定的排版（比如字体、图片位置不会乱），常用于存储合同、论文、手册等。但它对大模型来说很难直接理解，因为它是二进制形式存储的（类似电脑才能“看”懂的机器语言），而且可能包含页眉页脚、复杂图像或表格。大模型需要的是“干净的纯文本”，所以要把 PDF 里有用的文字内容“提取”出来，去掉那些没用的格式和噪声。  

### 难点与解析
| 问题类型 | 特征 | 解决方案 |
|---------|------|----------|
| 文本型PDF | 可提取文字但含页眉页脚 | 正则表达式清洗 |
| 扫描型PDF | 文字以图片形式存储 | OCR光学字符识别 |
| 加密PDF | 访问需要密码 | 解密后处理 |

### Python处理代码
```python
import PyPDF2
import re

def extract_pdf_text(pdf_path):
    """提取PDF文本内容"""
    text = ""
    with open(pdf_path, "rb") as file:
        reader = PyPDF2.PdfReader(file)
        for page in reader.pages:
            page_text = page.extract_text()
            if page_text:
                text += page_text
    return text

def clean_pdf_text(text):
    """清洗PDF文本"""
    # 移除页眉页脚
    cleaned_text = re.sub(r"第\s*\d+\s*页", "", text)
    # 压缩空白字符
    cleaned_text = re.sub(r"\s+", " ", cleaned_text).strip()
    return cleaned_text

# 使用示例
pdf_path = "code/document.pdf"
raw_text = extract_pdf_text(pdf_path)
print("原始文本:"+ raw_text)
print("处理后:" + clean_pdf_text(raw_text))
```

### 处理效果对比
```diff
- 原始文本: "第1页\n\n合同编号：XYZ-2023\n甲方：ABC公司...第2页\n1.1条款..."
+ 处理后: "合同编号：XYZ-2023 甲方：ABC公司...1.1条款..."
```

## 2：TXT文档处理

>TXT 是一种纯文本格式，常用于存储纯文本文件，比如小说、代码、日志等。它没有格式，所以大模型可以直接理解。但有时它可能包含编码错误、噪声内容或结构混乱，需要清洗。

### 难点与解析
| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 编码错误 | UTF-8/GBK编码冲突 | 多编码尝试读取 |
| 噪声内容 | 无效空行/特殊字符 | 正则过滤清洗 |
| 结构混乱 | 缺乏自然分段 | 语义/规则分段 |

### Python处理代码
```python
import re

def read_txt_with_encoding(txt_path):
    """多编码尝试读取TXT文件"""
    encodings = ["utf-8", "gbk", "latin-1"]
    for enc in encodings:
        try:
            with open(txt_path, "r", encoding=enc) as f:
                return f.read()
        except UnicodeDecodeError:
            continue
    raise ValueError("无法识别编码")

def clean_txt_text(text):
    """清洗文本内容"""
    # 移除空行
    lines = [line.strip() for line in text.split("\n") if line.strip()]
    cleaned_text = " ".join(lines)
    # 过滤特殊字符
    cleaned_text = re.sub(r"[^\w\s\u4e00-\u9fa5]", "", cleaned_text)
    return cleaned_text

# 使用示例
txt_path = "data.txt"
raw_text = read_txt_with_encoding(txt_path)
clean_text = clean_txt_text(raw_text)
```

## 3：Word文档处理

>Word文档有丰富的格式（比如标题是粗体、变大字号，正文是普通字体）。但大模型通常不需要这些格式，只需要文字内容。而且，我们还需要区分开标题和正文（比如标题更重要，结构上要分开），如果有表格，也要把表格内容转成文字形式，方便大模型理解。

### 难点与解析
| 挑战点 | 影响 | 解决方案 |
|--------|------|----------|
| 格式样式 | 干扰内容提取 | 解析样式元数据 |
| 表格图像 | 非文本内容处理困难 | 表格转结构化数据 |
| 标题层级 | 丧失文档结构 | 识别标题样式级别 |

### Python处理代码
```python
from docx import Document

def extract_word_content(word_path):
    """提取Word结构化内容"""
    doc = Document(word_path)
    content_list = []
  
    for para in doc.paragraphs:
        para_text = para.text.strip()
        if not para_text:
            continue
          
        style_name = para.style.name
        if style_name.startswith("Heading"):
            # 标题处理
            content_list.append({
                "type": "heading",
                "level": int(style_name[-1]),
                "content": para_text
            })
        else:
            # 正文处理
            content_list.append({
                "type": "text",
                "content": para_text
            })
  
    return content_list

# 使用示例
word_path = "report.docx"
content = extract_word_content(word_path)
print(content)
```

### 结构化输出示例
```json
[
  {"type": "heading", "level": 1, "content": "项目总结报告"},
  {"type": "text", "content": "本项目自2023年1月启动..."},
  {"type": "heading", "level": 2, "content": "成果展示"},
]
```

## 4：Markdown文档处理实战

>Markdown是一种轻量级标记语言，常用于编写文档、博客等。它有丰富的格式（比如标题是#号，列表是*号），但大模型通常不需要这些格式，只需要文字内容。而且，我们还需要区分开标题和正文（比如标题更重要，结构上要分开），如果有代码块，也要把代码块内容转成文字形式，方便大模型理解。

### 难点与解析
| 挑战 | 影响 | 解决方案 |
|------|------|----------|
| 标记干扰 | #、*等符号干扰 | 正则表达式清除 |
| 结构信息 | 标题层级丢失 | 保留层级缩进 |
| 代码块 | 技术内容处理 | 特别标注保留 |

### 处理方法1：正则处理（纯文本提取,会忽略标记）
```python
import re

def md_to_clean_text(md_content):
    """正则清洗Markdown"""
    # 清除标题标记
    text = re.sub(r'^#+\s', '', md_content, flags=re.MULTILINE)
    # 清除列表标记
    text = re.sub(r'^\s*[-*0-9.]+\s', '', text, flags=re.MULTILINE)
    # 清除链接
    text = re.sub(r'\[.*?\]\(.*?\)', '', text)
    # 清除代码块
    text = re.sub(r'```[\s\S]*?```', '', text)
    # 合并空格
    text = re.sub(r'\s+', ' ', text).strip()
    return text
```

### 处理方法2：HTML转换
```python
from bs4 import BeautifulSoup
import markdown2

def md_to_html_text(md_content):
    """通过HTML转换处理Markdown"""
    html = markdown2.markdown(md_content)
    soup = BeautifulSoup(html, 'html.parser')
    return soup.get_text(separator=' ', strip=True)
```

### 层级结构保留方案
```python
def md_keep_structure(md_content):
    """保留Markdown层级结构"""
    lines = md_content.split('\n')
    result = []
  
    for line in lines:
        line = line.strip()
        if line.startswith('#'):
            level = line.count('#')
            title = line.lstrip('#').strip()
            result.append(f"{'  '*(level-1)}{title}")
        elif line:
            result.append(line)
  
    return '\n'.join(result)
```